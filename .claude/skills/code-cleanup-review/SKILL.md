# 通用代码清理审查 Skill
---
name: code-cleanup-review
description: 通用代码清理审查，适用于所有编程语言、框架和文件类型。  基于 KISS/DRY/单一职责 原则，检测并清理：死代码、冗余逻辑、过复杂模块。  提供语言无关的判断标准和清理原则。
---


## 核心原则

```
┌─────────────────────────────────────────────────────────────┐
│  KISS 简单至上    能删就删，不过度设计                       │
│  DRY  不重复      相同逻辑只出现一次，提取为通用逻辑         │
│  单一职责         一个模块/函数只做一件事                    │
│  最小依赖         只引入真正需要的依赖                       │
└─────────────────────────────────────────────────────────────┘
```

---

## 第一部分：识别冗余类型

### 1.1 代码冗余类型清单

【类型A】完全无用代码
  ├── 未调用的函数/方法
  ├── 未使用的变量/常量
  ├── 未引用的模块/导入
  ├── 被注释掉的代码块
  ├── 永远返回常量值的条件分支
  └── 空函数（只有声明没有实现）

【类型B】功能重叠代码
  ├── 执行相同逻辑的重复函数
  ├── 可以合并的相似函数
  ├── 多处复制粘贴的代码片段
  └── 同名不同实现的函数

【类型C】过度兼容代码
  ├── 针对已废弃平台的条件分支
  ├── 永远为假/永远为真的条件判断
  ├── 旧API兼容层（无用户使用）
  └── 已移除功能的残余代码

【类型D】结构冗余代码
  ├── 单个文件代码行数过多
  ├── 函数参数过多（>4个）
  ├── 函数过长（单一函数>50行）
  ├── 类/对象属性过多
  └── 嵌套层级过深（>3层）

【类型E】逻辑冗余代码
  ├── 无用的空catch块
  ├── 冗余的条件判断
  ├── 可以简化的布尔逻辑
  ├── 无效的输入验证
  └── 已确定结果的重复计算

### 1.2 冗余判断标准

判断某段代码是否冗余的标准：

【标准1】可达性测试
  问：这段代码是否可能被执行？
  判定：
    ✅ 不可达 → 删除（#if 0, if False 等）
    ✅ 无调用链 → 可能删除（需验证）
    ✅ 有调用但无测试覆盖 → 谨慎删除

【标准2】功能替代测试
  问：是否有其他代码实现了相同功能？
  判定：
    ✅ 完全相同 → DRY合并
    ✅ 大部分相同 → 提取公共部分
    ✅ 功能类似但目的不同 → 保留（但文档说明差异）

【标准3】依赖关系测试
  问：删除后会影响哪些功能？
  判定：
    ✅ 无依赖 → 安全删除
    ✅ 内部依赖 → 重构后删除
    ✅ 外部API暴露 → 标记废弃，不直接删除

【标准4】时间衰减测试
  问：这段代码是何时添加的？为什么添加？
  判定：
    ✅ 超过3个月未维护 → 评估是否仍需
    ✅ 对应功能已下线 → 删除
    ✅ 纯实验代码 → 删除

## 第二部分：文件复杂度评估

### 2.1 文件复杂度指标

【指标1】代码行数
  阈值：
    普通文件 > 300 行 → 需评估拆分
    核心模块 > 500 行 → 建议拆分
    配置文件 > 1000 行 → 考虑结构重组

  评估方法：
    统计有效代码行（排除空行、注释）
    关注：文件是否在持续增长？

【指标2】函数/方法数量
  阈值：
    单文件函数 > 20 个 → 检查是否可拆分模块
    单文件类 > 5 个 → 检查模块边界

  评估方法：
    统计公开函数（public methods）
    统计内部函数（private methods）
    比例：公开:内部 是否合理？

【指标3】嵌套深度
  阈值：
    条件/循环嵌套 > 3 层 → 需重构
    回调/Promise 链 > 3 层 → 需简化

  评估方法：
    计算最大缩进层级
    统计 if/for/while/switch 嵌套

【指标4】扇入扇出
  扇入：该模块被多少其他模块调用
  扇出：该模块依赖多少其他模块

  阈值：
    扇出 > 10 → 考虑拆分
    扇入 = 0 → 可能废弃
    扇入极高 + 扇出极高 → 核心模块，需谨慎拆分

### 2.2 复杂度处理原则

【原则1】文件拆分
  当文件超过阈值时：
    1. 识别独立的业务功能
    2. 识别独立的工具函数
    3. 识别独立的配置数据
    4. 分别提取到独立文件
    5. 通过导入关系组合

【原则2】函数重构
  当函数超过阈值时：
    1. 单一职责：每个函数只做一件事
    2. 短小精悍：理想 < 20 行
    3. 参数精简：理想 < 4 个
    4. 命名清晰：见名知意

【原则3】嵌套简化
  当嵌套过深时：
    1. 提取独立判断为变量
    2. 使用卫语句提前返回
    3. 使用多态替代条件
    4. 链式调用替代嵌套

## 第三部分：清理优先级

### 3.1 清理风险等级

【P0 - 安全删除】
  风险：极低
  包含：
    ├── 被注释的代码
    ├── #if 0 / if False 包裹的代码
    ├── 未导出的内部函数
    ├── 调试日志语句
    └── 永远为空的 catch 块

【P1 - 低风险删除】
  风险：低
  包含：
    ├── 内部工具函数（需确认无调用）
    ├── 重复代码片段（需确认无差异）
    ├── 简单兼容代码（需确认无用户）
    └── 未使用的导入语句

【P2 - 中风险删除】
  风险：中
  包含：
    ├── 公共函数（需确认无调用）
    ├── 配置数据（需确认无引用）
    ├── 废弃功能入口（需确认无流量）
    └── 兼容层代码（需确认无依赖）

【P3 - 高风险删除】
  风险：高
  包含：
    ├── 核心模块
    ├── 公共API
    ├── 数据库模型
    └── 影响外部集成
    

### 3.2 清理决策流程

        ┌─────────────────┐
        │  发现可疑代码   │
        └────────┬────────┘
                 ▼
        ┌─────────────────┐
        │  评估风险等级   │
        └────────┬────────┘
                 ▼
        ┌─────────────────┐
        │  P0-P1 直接删除 │
        │  P2 验证后删除  │
        │  P3 评估后决策  │
        └────────┬────────┘
                 ▼
        ┌─────────────────┐
        │  执行清理并测试  │
        └────────┬────────┘
                 ▼
        ┌─────────────────┐
        │  验证功能正常   │
        └─────────────────┘

## 第四部分：通用清理规则

### 4.1 被注释代码规则

【规则A1】删除而非保留
  原则：版本控制是代码的保险，不是注释代码
  判定：
    ✅ 被注释超过 1 个月 → 删除
    ✅ 对应功能已下线 → 删除
    ✅ 只是调试代码 → 删除

  例外：
    ⚠️ 重要算法的文档注释 → 保留（改为文档字符串）
    ⚠️ 复杂业务的说明注释 → 保留（改为文档字符串）
    ⚠️ FIXME/TODO 且未解决 → 保留（但添加时间戳）

【规则A2】注释质量标准
  好注释：
    ├── 解释为什么（Why），而非做什么（What）
    ├── 解释业务背景和决策原因
    ├── 标记待办事项和负责人
    └── 标记复杂逻辑的设计意图

  坏注释：
    ├── 与代码矛盾的注释
    ├── 过时失效的注释
    ├── 明显的重复代码注释
    └── 大量被注释的代码块

### 4.2 重复代码规则

【规则D1】DRY 检测
  相同逻辑出现：
    2次 → 可接受（有时比强制抽象更清晰）
    3次 → 必须提取公共函数
    >3次 → 强烈建议提取公共函数

【规则D2】重复判定
  相似度判断标准：
    ✅ 相同代码结构 + 相同语义 → 直接合并
    ✅ 代码相似但参数不同 → 提取为参数化函数
    ✅ 代码相似但目的不同 → 保持分离（但需文档说明）

【规则D3】合并策略
  小片段（< 10行）：
    → 提取为内部辅助函数

  中等片段（10-50行）：
    → 提取为公共模块函数

  大片段（> 50行）：
    → 提取为独立模块或服务

### 4.3 兼容代码规则

【规则C1】版本窗口
  设定支持的最低版本：
    ├── 云服务：通常保留 1-2 个主版本
    ├── 客户端库：通常保留 2-3 个主版本
    └── 内部库：通常只保留当前版本

  过期清理：
    ✅ 低于最低支持版本的条件 → 删除
    ✅ 旧API兼容层（无活跃用户）→ 标记废弃
    ✅ 已关闭的 Issue 对应代码 → 删除

【规则C2】平台检测
  检查点：
    └── 是否仍有用户使用旧平台？
    └── 旧平台流量占比是否 < 1%？
    └── 维护成本是否超过收益？

  决策：
    ✅ 流量 < 1% + 维护成本高 → 移除兼容
    ✅ 有企业客户要求 → 保留
    ✅ 下个主版本移除 → 开始标记废弃

### 4.4 逻辑简化规则

【规则L1】条件判断
  可简化场景：
    ├── if True: ... else: ... → 直接执行
    ├── if False: ... else: ... → 执行 else 分支
    ├── if x: return True; else: return False → return x
    ├── if x: return False; else: return True → return not x
    ├── 多层 if 判断 → 卫语句提前返回
    └── 复杂布尔表达式 → 提取为命名变量

【规则L2】空操作处理
  空 catch 块：
    ✅ 必须记录日志（即使只是 warn）
    ✅ 或添加注释说明为什么可以忽略
    ✅ 或转换为更明确的异常处理

  空函数：
    ✅ 纯虚接口实现 → 保留（但文档说明）
    └── 非必要空实现 → 删除函数

【规则L3】计算优化
  重复计算：
    ├── 相同输入重复计算 → 缓存结果
    ├── 循环内重复计算 → 提取到循环外
    └── 幂等计算结果 → 使用常量/配置

## 第五部分：清理验证标准

### 5.1 清理后验证清单

【验证1】功能完整性
  □ 核心功能测试通过
  □ 边界条件测试通过
  □ 错误处理测试通过
  □ 集成测试通过

【验证2】构建/编译
  □ 项目构建成功
  □ 无新警告产生
  □ 类型检查通过（如果有）
  □ Lint 检查通过

【验证3】性能影响
  □ 无回归性性能下降
  □ 内存使用无明显增加
  □ 启动时间无明显增加

【验证4】依赖关系
  □ 无悬空导入
  □ 无断裂调用链
  □ 无缺失依赖
### 5.2 回滚标准

需要回滚的信号：
  □ 测试失败（无法快速修复）
  □ 构建失败（无法快速修复）
  □ 核心功能异常
  □ 引入新 Bug（影响用户）
  □ 性能显著下降

回滚流程：
  1. 从版本控制恢复备份
  2. 标记清理任务为失败
  3. 记录问题原因
  4. 分析是否可以在修复后重试

## 第六部分：持续维护机制

### 6.1 定期审查周期

【周期1】每次功能发布后
  检查：
    ├── 新增代码是否违反原则
    ├── 是否有临时方案未清理
    └── 是否有注释代码未删除

【周期2】每月技术债审查
  检查：
    ├── 文件复杂度是否上升
    ├── 重复代码是否增加
    ├── 兼容代码是否仍需
    └── 废弃功能是否可清理

【周期3】每季度架构审查
  检查：
    ├── 模块边界是否清晰
    ├── 依赖关系是否合理
    ├── 核心模块是否过于庞大
    └── 是否有重构机会

### 6.2 预防机制

【预防1】代码审查清单
  合并前检查：
    □ 是否有被注释的代码
    □ 是否有重复代码
    □ 是否违反单一职责
    □ 是否有未使用的导入
    □ 函数是否过于复杂

【预防2】自动化检测
  CI 集成：
    ├── 代码复杂度检测
    ├── 重复代码检测
    ├── 死代码检测
    ├── 未使用导入检测
    └── 文件长度检测

【预防3】规范约束
  项目规范：
    ├── 单文件最大行数
    ├── 单函数最大行数
    ├── 最大嵌套层级
    ├── 重复代码阈值
    └── 禁止特定反模式

## 第七部分：清理决策框架

### 7.1 决策矩阵

                    重要              不重要
              ┌──────────────┬──────────────┐
   使用       │   保留       │   删除       │
              │              │   或归档     │
              ├──────────────┼──────────────┤
   不使用     │   评估       │   删除       │
              │   迁移/归档  │   （安全）   │
              └──────────────┴──────────────┘

### 7.2 决策问题清单

在清理任何代码前，问自己：

【问题1】可达性
  Q: 这段代码是否可能被调用？
  A1: 否 → 删除
  A2: 是 → 继续问题2

【问题2】必要性
  Q: 这段代码是否实现不可替代的功能？
  A1: 否 → 删除
  A2: 是 → 继续问题3

【问题3】依赖性
  Q: 删除后会影响哪些功能？
  A1: 无 → 安全删除
  A2: 有 → 继续问题4

【问题4】可维护性
  Q: 这段代码是否难以理解和维护？
  A1: 是 → 重构或重写
  A2: 否 → 保留但添加文档

## 总结

代码清理的核心目标：

┌────────────────────────────────────────────────────────────┐
│  ✓ 删除死代码                                             │
│  ✓ 消除重复逻辑                                           │
│  ✓ 简化复杂结构                                           │
│  ✓ 移除过期兼容                                           │
│  ✓ 保持代码库精简                                         │
└────────────────────────────────────────────────────────────┘

清理的信心来源：

┌────────────────────────────────────────────────────────────┐
│  ✓ 版本控制（随时可以恢复）                               │
│  ✓ 自动化测试（验证功能正确）                             │
│  ✓ 渐进式清理（一次清理一小部分）                         │
│  ✓ 风险评估（高风险代码谨慎处理）                         │
└────────────────────────────────────────────────────────────┘

记住：
  删掉的代码是最好的代码
  因为它不会产生新的 Bug
  也不需要持续维护

## 快速参考卡

【发现可疑代码 → 问自己】

1. 这段代码是否被调用？ → 无 → 删除
2. 这段代码做什么的？    → 已知 → 判断必要性
3. 有其他代码做同样的事？→ 有 → DRY 合并
4. 是否针对旧版本？      → 是 → 评估版本窗口
5. 函数/文件是否过长？   → 是 → 拆分重构

【清理优先级】

P0: 被注释代码、调试代码、#if 0
P1: 内部函数、重复代码、简单兼容
P2: 公共函数、配置数据、废弃功能
P3: 核心模块、公共API（需评估）

【验证标准】

清理后必须：
  ✓ 测试通过
  ✓ 构建成功
  ✓ 无回归
  ✓ 可回滚