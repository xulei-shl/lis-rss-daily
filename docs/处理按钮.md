处理按钮说明（基于当前实际代码）

本文件用于说明页面“处理”相关按钮的真实行为，以及手动触发与自动触发的差异。

一、页面按钮与触发路径

1. 文章列表页 /articles
- 按钮：批量处理
- 前端：src/views/articles.ejs → processBatch()
- 请求：POST /api/articles/process-batch
- 后端：src/api/article-process.ts → triggerBatchProcess()
- 执行：processBatchArticles() → processArticle() → runPipeline()

2. 文章列表页 /articles（单条卡片）
- 按钮：处理
- 显示条件：process_status 为 pending 或 failed 才显示
- 前端：src/views/articles.ejs → processArticle(id)
- 请求：POST /api/articles/:id/process
- 后端：src/api/article-process.ts → triggerProcess()
- 执行：processArticle() → runPipeline()

3. 文章详情页 /articles/:id
- 按钮：重新处理
- 显示条件：process_status 为 pending 或 failed 才显示
- 前端：src/views/article-detail.ejs → processArticle()
- 请求：POST /api/articles/:id/process
- 后端：同上
- 执行：processArticle() → runPipeline()

二、Pipeline 三阶段（手动触发会走完整流程）

Stage 1 抓取（scrape）
- 调用：scrapeUrl(url) → Playwright + Defuddle
- 保存字段：markdown_content（前提是抓取质量通过保护）
- 质量保护：
  - 包含验证码/反爬关键词会被拒绝
  - 过短内容会被拒绝
  - 明显短于 RSS 正文的内容会被拒绝

Stage 2 分析（analyze）
- 调用：analyzeArticle()
- 主要写入：summary（LLM 摘要）

Stage 3 导出（export）
- 导出 Markdown 到 data/exports/
- 导出失败不影响处理结果

三、字段与页面展示关系

- content：RSS 入库正文（总是保留，代表 RSS 原始正文）
- markdown_content：
  - 入库时与 content 相同
  - 手动抓取成功且通过质量保护时才覆盖为抓取结果

详情页展示策略：
- 始终展示 content（RSS 正文）
- markdown_content 存在且与 content 不同时，额外展示“抓取全文”

四、自动逻辑与手动逻辑对照

1. 自动处理（RSS 定时）
- 触发位置：src/rss-scheduler.ts
- 触发链路：
  RSS 抓取 → 入库 → 自动过滤 → 通过则自动处理
- 自动处理调用：processArticle(article.id, userId, { skipScrape: true })
- 结果：跳过抓取阶段，只用已有内容做摘要与导出

2. 手动处理（按钮）
- 触发位置：文章列表页/详情页按钮
- 触发链路：HTTP 接口触发 processArticle()
- 结果：走完整 Pipeline（含抓取）

对照总结：
| 维度 | 自动处理 | 手动处理 |
| --- | --- | --- |
| 触发来源 | RSS 定时任务 | 页面按钮 |
| 是否抓取原文 | 否（skipScrape=true） | 是（会尝试抓取） |
| 使用内容 | 仅 RSS 内容 | 抓取成功则覆盖 markdown_content |
| 处理范围 | 过滤通过的新增文章 | 单篇或批量 |

五、重要约束

- 只有 filter_status = passed 的文章才会进入处理流程
- process_status 为 processing/completed 时按钮不显示
