# 统一检索接口文档

## 概述

统一检索接口提供了一个单一的入口点来执行所有类型的文章搜索操作，包括语义搜索、关键词搜索、混合搜索和相关文章推荐。

## 核心特性

- **四种检索模式**：语义、关键词、混合、相关文章
- **Chroma 客户端单例**：自动管理连接，避免连接问题
- **智能回退机制**：混合模式下语义检索失败自动回退到关键词检索
- **缓存支持**：相关文章结果可缓存以提升性能
- **统一分数归一化**：支持多种融合策略

## 快速开始

```typescript
import { search, SearchMode } from './vector/search.js';

// 混合检索（语义 + 关键词）
const results = await search({
  mode: SearchMode.HYBRID,
  userId: 1,
  query: 'machine learning',
  limit: 10,
});

// 相关文章推荐
const related = await search({
  mode: SearchMode.RELATED,
  userId: 1,
  articleId: 123,
  limit: 5,
  useCache: true,
});
```

## API 参考

### SearchMode 枚举

```typescript
enum SearchMode {
  SEMANTIC = 'semantic',   // 纯语义检索（向量相似度）
  KEYWORD = 'keyword',     // 纯关键词检索（SQL LIKE）
  HYBRID = 'hybrid',       // 混合检索（语义 + 关键词）
  RELATED = 'related',     // 相关文章检索
}
```

### SearchRequest 接口

```typescript
interface SearchRequest {
  // 必需参数
  mode: SearchMode;        // 检索模式
  userId: number;          // 用户 ID

  // 查询输入（根据 mode 提供）
  query?: string;          // 文本查询（SEMANTIC/KEYWORD/HYBRID）
  articleId?: number;      // 文章 ID（RELATED）

  // 检索参数
  limit?: number;          // 返回数量（默认 10）
  offset?: number;         // 分页偏移（默认 0）

  // 融合参数（HYBRID/RELATED）
  semanticWeight?: number; // 语义权重（默认 0.7）
  keywordWeight?: number;  // 关键词权重（默认 0.3）
  normalizeScores?: boolean; // 是否归一化语义分数（默认 true）

  // 缓存参数（RELATED）
  useCache?: boolean;      // 是否使用缓存（默认 true）
  refreshCache?: boolean;  // 强制刷新缓存（默认 false）

  // 回退控制（HYBRID）
  fallbackEnabled?: boolean; // 是否启用回退（默认 true）
}
```

### SearchResponse 接口

```typescript
interface SearchResponse {
  results: SearchResult[]; // 检索结果
  mode: SearchMode;        // 实际使用的模式
  query?: string;          // 查询文本
  total: number;           // 结果总数
  page?: number;           // 当前页码
  limit?: number;          // 每页数量
  cached: boolean;         // 是否来自缓存
  fallback?: boolean;      // 是否使用了回退机制
}
```

### SearchResult 接口

```typescript
interface SearchResult {
  articleId: number;       // 文章 ID
  score: number;           // 最终融合分数
  semanticScore?: number;  // 语义分数（调试用）
  keywordScore?: number;   // 关键词分数（调试用）
  metadata?: {
    title: string;         // 标题
    url: string;           // URL
    summary: string | null; // 摘要
    published_at: string | null; // 发布时间
    rss_source_name?: string; // RSS 源名称
  };
}
```

## 使用示例

### 1. 语义检索

基于向量相似度的语义搜索：

```typescript
const response = await search({
  mode: SearchMode.SEMANTIC,
  userId: 1,
  query: '人工智能最新进展',
  limit: 10,
});

console.log(`找到 ${response.total} 篇相关文章`);
for (const result of response.results) {
  console.log(`${result.metadata?.title} - 相关度: ${result.score}`);
}
```

### 2. 关键词检索

基于 SQL LIKE 的关键词匹配：

```typescript
const response = await search({
  mode: SearchMode.KEYWORD,
  userId: 1,
  query: 'machine learning',
  limit: 20,
});
```

### 3. 混合检索

语义 + 关键词融合（默认 70/30 权重）：

```typescript
const response = await search({
  mode: SearchMode.HYBRID,
  userId: 1,
  query: '深度学习',
  limit: 10,
  semanticWeight: 0.7,
  keywordWeight: 0.3,
  normalizeScores: true, // 归一化语义分数
});

// 检查是否使用了回退机制
if (response.fallback) {
  console.log('语义检索失败，已回退到关键词检索');
}
```

### 4. 相关文章推荐

基于文章内容推荐相关文章（支持缓存）：

```typescript
// 首次调用：计算并缓存
const response1 = await search({
  mode: SearchMode.RELATED,
  userId: 1,
  articleId: 123,
  limit: 5,
  useCache: true,
});
console.log(response1.cached); // false

// 再次调用：从缓存读取
const response2 = await search({
  mode: SearchMode.RELATED,
  userId: 1,
  articleId: 123,
  limit: 5,
  useCache: true,
});
console.log(response2.cached); // true

// 强制刷新缓存
const response3 = await search({
  mode: SearchMode.RELATED,
  userId: 1,
  articleId: 123,
  limit: 5,
  useCache: false,
  refreshCache: true,
});
```

### 5. 分页检索

```typescript
const page = 2;
const limit = 20;

const response = await search({
  mode: SearchMode.HYBRID,
  userId: 1,
  query: '检索',
  limit,
  offset: (page - 1) * limit,
});

console.log(`第 ${response.page} 页，共 ${Math.ceil(response.total / limit)} 页`);
```

## 回退机制

### 工作原理

在 `HYBRID` 模式下，如果语义检索失败（如 Chroma 不可用），系统会自动回退到纯关键词检索，确保搜索功能始终可用。

```typescript
const response = await search({
  mode: SearchMode.HYBRID,
  userId: 1,
  query: '测试',
  limit: 10,
  fallbackEnabled: true, // 启用回退（默认）
});

if (response.fallback) {
  console.log('使用了回退机制');
}
```

### 禁用回退

如果希望语义检索失败时抛出错误：

```typescript
const response = await search({
  mode: SearchMode.HYBRID,
  userId: 1,
  query: '测试',
  limit: 10,
  fallbackEnabled: false, // 禁用回退
});
```

## 分数归一化

### 归一化模式（推荐用于搜索页）

```typescript
const response = await search({
  mode: SearchMode.HYBRID,
  userId: 1,
  query: '检索',
  limit: 10,
  normalizeScores: true, // 语义分数归一化后再融合
});

// 融合公式：finalScore = (semanticScore / maxSemScore) * 0.7 + keywordScore * 0.3
```

### 非归一化模式（用于相关文章）

```typescript
const response = await search({
  mode: SearchMode.RELATED,
  userId: 1,
  articleId: 123,
  limit: 5,
  normalizeScores: false, // 直接融合原始分数
});

// 融合公式：finalScore = semanticScore * 0.7 + keywordScore * 0.3
```

## 在 API 路由中使用

### 搜索页路由

```typescript
// src/api/routes/search.routes.ts
import { search, SearchMode } from '../../vector/search.js';

router.get('/search', requireAuth, async (req: AuthRequest, res) => {
  const query = req.query.q as string;
  const mode = (req.query.mode as string) || 'hybrid';
  const page = parseInt(req.query.page as string) || 1;
  const limit = parseInt(req.query.limit as string) || 10;

  const searchMode = mode === 'semantic' ? SearchMode.SEMANTIC
    : mode === 'keyword' ? SearchMode.KEYWORD
    : SearchMode.HYBRID;

  const response = await search({
    mode: searchMode,
    userId: req.userId!,
    query: query.trim(),
    limit,
    offset: (page - 1) * limit,
    normalizeScores: true,
  });

  res.json({
    results: response.results.map((r) => ({
      id: r.articleId,
      title: r.metadata?.title,
      url: r.metadata?.url,
      summary: r.metadata?.summary,
      relevance: r.score,
    })),
    total: response.total,
    page: response.page,
    fallback: response.fallback,
  });
});
```

### 相关文章接口

```typescript
// src/api/articles.ts
import { search, SearchMode } from '../vector/search.js';

export async function getRelatedArticles(
  articleId: number,
  userId: number,
  limit: number = 5
): Promise<RelatedArticle[]> {
  const response = await search({
    mode: SearchMode.RELATED,
    userId,
    articleId,
    limit,
    normalizeScores: false,
    useCache: true,
  });

  return response.results.map((r) => ({
    id: r.articleId,
    title: r.metadata?.title || '',
    url: r.metadata?.url || '',
    summary: r.metadata?.summary ?? null,
    published_at: r.metadata?.published_at ?? null,
    score: r.score,
  }));
}
```

## 性能优化

### 缓存策略

相关文章检索支持缓存，首次计算后会保存到数据库：

```typescript
// article_related 表结构
// - article_id: 当前文章 ID
// - related_article_id: 相关文章 ID
// - score: 相关度分数
// - created_at: 缓存时间
```

### 并发检索

混合模式下，语义检索和关键词检索并行执行：

```typescript
const [semanticResults, keywordResults] = await Promise.all([
  semanticSearchOnly(userId, query, limit),
  keywordSearchOnly(userId, query, limit),
]);
```

### Chroma 连接复用

使用单例模式复用 Chroma 客户端连接，避免重复创建：

```typescript
// src/vector/chroma-client.ts
const clientCache = new Map<number, ClientCache>();

export async function getCollection(userId: number) {
  // 每个用户一个缓存的客户端实例
  if (clientCache.has(userId)) {
    return clientCache.get(userId)!;
  }
  // 创建新客户端并缓存
}
```

## 错误处理

### 语义检索失败

```typescript
try {
  const response = await search({
    mode: SearchMode.SEMANTIC,
    userId: 1,
    query: '测试',
    limit: 10,
  });
} catch (error) {
  console.error('检索失败:', error);
  // 语义模式无法回退，返回空结果
}
```

### 混合模式回退

```typescript
const response = await search({
  mode: SearchMode.HYBRID,
  userId: 1,
  query: '测试',
  limit: 10,
});

if (response.fallback) {
  console.warn('语义检索失败，已回退到关键词检索');
}
```

## 架构说明

### 文件结构

```
src/vector/
├── chroma-client.ts      # Chroma 客户端单例
├── search-service.ts     # 统一检索服务（核心）
├── search.ts             # 接口导出
├── vector-store.ts       # 向量存储操作
├── embedding-client.ts   # Embedding 服务
├── reranker.ts           # 重排序服务
└── text-builder.ts       # 文本构建工具
```

### 调用流程

```
API 层
  ↓
search() 统一入口
  ↓
┌─────────────┬──────────────┬──────────────┬──────────────┐
│ SEMANTIC    │ KEYWORD      │ HYBRID       │ RELATED      │
├─────────────┼──────────────┼──────────────┼──────────────┤
│ → embedding │ → SQL LIKE   │ → semantic   │ → semantic   │
│ → query     │ → relevance  │ → keyword    │ → keyword    │
│ → rerank    │ → sort       │ → merge      │ → merge      │
│             │              │ → fallback?  │ → cache      │
└─────────────┴──────────────┴──────────────┴──────────────┘
  ↓
enrichWithMetadata() - 加载文章详情
  ↓
SearchResponse
```

## 配置参数

### 环境变量

```bash
# Chroma 配置（在 settings 表中也可配置）
CHROMA_HOST=127.0.0.1
CHROMA_PORT=8000
CHROMA_COLLECTION=articles
CHROMA_DISTANCE_METRIC=cosine
```

### 默认值

```typescript
const DEFAULT_LIMIT = 10;
const DEFAULT_SEMANTIC_WEIGHT = 0.7;
const DEFAULT_KEYWORD_WEIGHT = 0.3;
```

## 常见问题

### Q: 如何选择合适的检索模式？

- **SEMANTIC**: 适合语义搜索，理解查询意图
- **KEYWORD**: 适合精确匹配，性能最好
- **HYBRID**: 平衡准确性和召回率，推荐使用
- **RELATED**: 适合文章推荐

### Q: 为什么相关文章使用非归一化模式？

相关文章的语义分数范围相对稳定，不需要归一化。而搜索页的查询多样性大，归一化可以避免某些查询的分数过高或过低。

### Q: 如何提高检索性能？

1. 使用 `useCache: true` 启用缓存
2. 合理设置 `limit` 避免返回过多结果
3. 在高并发场景下使用 `KEYWORD` 模式

### Q: Chroma 连接失败怎么办？

检查：
1. Chroma 服务是否启动（`scripts/start.bat`）
2. 配置是否正确（settings 表或环境变量）
3. 使用 `HYBRID` 模式启用回退机制

## 版本历史

### v1.0.0 (当前版本)

- 统一四种检索模式
- Chroma 客户端单例
- 智能回退机制
- 缓存支持
- 消除 ~200 行重复代码
